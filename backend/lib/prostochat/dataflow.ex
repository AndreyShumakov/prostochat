defmodule Prostochat.Dataflow do
  @moduledoc """
  Dataflow execution engine for Prostochat.

  Implements F(H): snapshot -> batch -> fixpoint mechanism.

  ## Core Concepts

  - **History H**: Current set of events
  - **Guard**: Model field with Condition + SetValue/SetDo
  - **Batch B(H)**: New events generated by active guards
  - **Fixpoint H***: History where B(H*) = empty

  ## Process

  1. Snapshot current history H
  2. Find active guards (Condition evaluates to true)
  3. Generate batch of new events from active guards
  4. Append batch to history
  5. Repeat until no new events (fixpoint)

  ## Usage

      # Execute one step
      {:ok, events} = Prostochat.Dataflow.execute_step()

      # Execute to fixpoint
      {:ok, iterations, events} = Prostochat.Dataflow.execute_to_fixpoint()
  """

  require Logger
  alias Prostochat.{Storage, Event, Query}

  @max_iterations 100

  @doc """
  Execute one dataflow step F(H) = H union B(H).

  Returns `{:ok, new_events}` where new_events is the list of generated events.
  """
  def execute_step(history \\ nil) do
    # 1. Snapshot
    h = case history do
      nil -> Storage.list()
      list when is_list(list) -> list
      _ -> Storage.list()
    end

    Logger.debug("[Dataflow] Executing step on #{length(h)} events")

    # 2. Find active guards
    active_guards = find_active_guards(h)
    Logger.info("[Dataflow] Found #{length(active_guards)} active guards")

    # 3. Generate batch
    batch = generate_batch(active_guards, h)
    Logger.info("[Dataflow] Generated batch of #{length(batch)} events")

    # 4. Append to storage
    results = Enum.map(batch, fn event_data ->
      case Storage.append(event_data) do
        {:ok, event} ->
          Logger.debug("[Dataflow] Appended: #{event.base}:#{event.type}")
          Event.to_map(event)
        {:error, reason} ->
          Logger.error("[Dataflow] Failed to append: #{inspect(reason)}")
          nil
      end
    end)
    |> Enum.filter(&(&1 != nil))

    {:ok, results}
  end

  @doc """
  Execute dataflow until fixpoint (no new events generated).

  Returns `{:ok, iterations, all_events}` or `{:error, reason, partial_events}`.
  """
  def execute_to_fixpoint(opts \\ []) do
    max_iter = Keyword.get(opts, :max_iterations, @max_iterations)
    Logger.info("[Dataflow] Starting fixpoint execution (max: #{max_iter})")
    execute_to_fixpoint_recursive(0, max_iter, [])
  end

  defp execute_to_fixpoint_recursive(iteration, max_iter, acc) when iteration >= max_iter do
    Logger.warning("[Dataflow] Max iterations (#{max_iter}) reached")
    {:error, :max_iterations_reached, acc}
  end

  defp execute_to_fixpoint_recursive(iteration, max_iter, acc) do
    Logger.debug("[Dataflow] Iteration #{iteration}")

    case execute_step() do
      {:ok, []} ->
        Logger.info("[Dataflow] Fixpoint reached after #{iteration} iterations, #{length(acc)} total events")
        {:ok, iteration, acc}

      {:ok, new_events} ->
        execute_to_fixpoint_recursive(iteration + 1, max_iter, acc ++ new_events)

      {:error, reason} ->
        {:error, reason, acc}
    end
  end

  @doc """
  Execute incremental dataflow - only check guards affected by new events.
  """
  def execute_incremental(new_events, _opts \\ []) do
    if Enum.empty?(new_events) do
      {:ok, []}
    else
      h = Storage.list()

      # Get affected concepts
      affected_concepts = new_events
      |> Enum.map(fn e -> e.base || e["base"] end)
      |> Enum.uniq()

      Logger.debug("[Dataflow Incremental] Affected concepts: #{inspect(affected_concepts)}")

      # Find guards for affected concepts
      active_guards = find_active_guards_for_concepts(h, affected_concepts)
      Logger.info("[Dataflow Incremental] Found #{length(active_guards)} active guards")

      # Generate and store
      batch = generate_batch(active_guards, h)

      results = Enum.map(batch, fn event_data ->
        case Storage.append(event_data) do
          {:ok, event} -> Event.to_map(event)
          {:error, _} -> nil
        end
      end)
      |> Enum.filter(&(&1 != nil))

      {:ok, results}
    end
  end

  # ============================================================
  # Guards extraction
  # ============================================================

  @doc """
  Find all active guards from models in history.

  A guard is active if:
  1. Has Condition that evaluates to true
  2. Has SetValue or SetDo action
  """
  def find_active_guards(history) do
    # Get all models
    models = Enum.filter(history, fn e -> e.type == "Model" end)

    Logger.debug("[Dataflow] Scanning #{length(models)} models for guards")

    # Extract guards from each model
    all_guards = Enum.flat_map(models, fn model ->
      extract_guards_from_model(model, history)
    end)

    Logger.debug("[Dataflow] Extracted #{length(all_guards)} potential guards")

    # Filter active guards
    active = Enum.filter(all_guards, fn guard ->
      is_guard_active?(guard, history)
    end)

    Logger.debug("[Dataflow] #{length(active)} guards are active")
    active
  end

  @doc """
  Find active guards only for specified concepts.
  """
  def find_active_guards_for_concepts(history, concepts) do
    models = Enum.filter(history, fn e ->
      e.type == "Model" and e.base in concepts
    end)

    all_guards = Enum.flat_map(models, fn model ->
      extract_guards_from_model(model, history)
    end)

    Enum.filter(all_guards, fn guard ->
      is_guard_active?(guard, history)
    end)
  end

  defp extract_guards_from_model(model, history) do
    # Find Attribute/Relation events with cause containing model.id (cause is now a list)
    children = Enum.filter(history, fn e ->
      model.id in (e.cause || []) and e.type in ["Attribute", "Relation"]
    end)

    Enum.flat_map(children, fn attr ->
      # Find restrictions with cause containing attr.id (cause is now a list)
      restrictions = Enum.filter(history, fn e ->
        attr.id in (e.cause || [])
      end)

      condition = Enum.find(restrictions, fn r -> r.type == "Condition" end)
      setvalue = Enum.find(restrictions, fn r -> r.type == "SetValue" end)
      setdo = Enum.find(restrictions, fn r -> r.type == "SetDo" end)

      if condition && (setvalue || setdo) do
        [%{
          model: model,
          attribute: attr,
          condition: condition,
          action: setvalue || setdo,
          action_type: if(setvalue, do: :set_value, else: :set_do)
        }]
      else
        []
      end
    end)
  end

  defp is_guard_active?(guard, history) do
    condition_expr = guard.condition.value

    # Build context for evaluation
    context = %{
      model: guard.model,
      attribute: guard.attribute,
      history: history,
      state: %{}
    }

    case Query.execute(condition_expr, context) do
      {:ok, true} -> true
      {:ok, 1} -> true
      {:ok, "true"} -> true
      {:ok, "1"} -> true
      _ ->
        # Fallback: simple pattern matching
        evaluate_condition_simple(condition_expr)
    end
  end

  defp evaluate_condition_simple(expr) do
    cond do
      expr in ["true", "1", "TRUE", "True"] -> true
      expr in ["false", "0", "FALSE", "False"] -> false
      String.contains?(expr, "Exists") -> true  # Assume exists
      true -> false
    end
  end

  # ============================================================
  # Batch generation
  # ============================================================

  defp generate_batch(active_guards, history) do
    Enum.flat_map(active_guards, fn guard ->
      emit_events(guard, history)
    end)
  end

  defp emit_events(guard, history) do
    case guard.action_type do
      :set_value -> emit_setvalue_events(guard, history)
      :set_do -> emit_setdo_events(guard, history)
    end
  end

  defp emit_setvalue_events(guard, history) do
    base_concept = guard.model.base

    # Find all individuals of this concept
    individuals = Enum.filter(history, fn e ->
      e.base == base_concept and e.type == "Individual"
    end)

    Logger.debug("[Dataflow] SetValue for #{length(individuals)} individuals of #{base_concept}")

    Enum.flat_map(individuals, fn individual ->
      # Check if individual already has this attribute
      existing = Enum.find(history, fn e ->
        e.base == individual.value and e.type == guard.attribute.value
      end)

      if existing do
        []
      else
        # Build state for this individual
        state = build_individual_state(individual.value, history)
        context = %{
          state: state,
          current_individual: individual.value,
          current_actor: "engine"
        }

        case Query.execute(guard.action.value, context) do
          {:ok, value} when value != nil ->
            Logger.info("[Dataflow] Generating: #{individual.value}:#{guard.attribute.value}:#{value}")

            [%{
              base: individual.value,
              type: guard.attribute.value,
              value: to_string(value),
              actor: "engine",
              model: guard.model.value,
              cause: [individual.id]  # cause is now a list
            }]

          _ ->
            []
        end
      end
    end)
  end

  defp emit_setdo_events(guard, history) do
    setdo_expr = guard.action.value
    Logger.debug("[Dataflow SetDo] Executing: #{setdo_expr}")

    case parse_setdo(setdo_expr) do
      {:create_individual, concept, name_expr} ->
        emit_create_individual(concept, name_expr, guard, history)

      {:set_property, individual_expr, property, value_expr} ->
        emit_set_property(individual_expr, property, value_expr, guard, history)

      {:error, _reason} ->
        []
    end
  end

  defp parse_setdo(expr) do
    cond do
      String.starts_with?(expr, "CreateIndividual(") ->
        case Regex.run(~r/CreateIndividual\(\s*(\w+)\s*,\s*(.+?)\s*\)/, expr) do
          [_, concept, name_expr] -> {:create_individual, concept, String.trim(name_expr)}
          _ -> {:error, "Invalid CreateIndividual syntax"}
        end

      String.starts_with?(expr, "SetProperty(") ->
        case Regex.run(~r/SetProperty\(\s*(.+?)\s*,\s*(\w+)\s*,\s*(.+?)\s*\)/, expr) do
          [_, ind, prop, val] -> {:set_property, String.trim(ind), prop, String.trim(val)}
          _ -> {:error, "Invalid SetProperty syntax"}
        end

      true ->
        {:error, "Unknown SetDo action"}
    end
  end

  defp emit_create_individual(concept, name_expr, _guard, history) do
    context = %{state: %{}, history: history}

    case Query.execute(name_expr, context) do
      {:ok, name} when is_binary(name) ->
        # Check if already exists
        existing = Enum.find(history, fn e ->
          e.base == concept and e.type == "Individual" and e.value == name
        end)

        if existing do
          []
        else
          Logger.info("[Dataflow SetDo] Creating: #{concept}:Individual:#{name}")

          [%{
            base: concept,
            type: "Individual",
            value: name,
            actor: "engine",
            model: "Model #{concept}"
          }]
        end

      _ ->
        []
    end
  end

  defp emit_set_property(individual_expr, property, value_expr, _guard, history) do
    context = %{state: %{}, history: history}

    individual = case Query.execute(individual_expr, context) do
      {:ok, val} when is_binary(val) -> val
      _ -> individual_expr
    end

    case Query.execute(value_expr, context) do
      {:ok, value} ->
        # Check if already exists
        existing = Enum.find(history, fn e ->
          e.base == individual and e.type == property
        end)

        if existing do
          []
        else
          Logger.info("[Dataflow SetDo] Setting: #{individual}:#{property}=#{value}")

          [%{
            base: individual,
            type: property,
            value: to_string(value),
            actor: "engine"
          }]
        end

      _ ->
        []
    end
  end

  defp build_individual_state(individual_base, history) do
    events = Enum.filter(history, fn e -> e.base == individual_base end)

    Enum.reduce(events, %{}, fn e, acc ->
      prev = Map.get(acc, e.type)

      cond do
        is_nil(prev) -> Map.put(acc, e.type, e.value)
        e.date >= prev -> Map.put(acc, e.type, e.value)
        true -> acc
      end
    end)
  end

  # ============================================================
  # Public API for listing guards
  # ============================================================

  @doc """
  List all guards from models.
  """
  def list_guards do
    history = Storage.list()
    models = Enum.filter(history, fn e -> e.type == "Model" end)

    Enum.flat_map(models, fn model ->
      extract_guards_from_model(model, history)
      |> Enum.map(fn g ->
        %{
          model: model.value,
          concept: model.base,
          field: g.attribute.value,
          condition: g.condition.value,
          action_type: g.action_type,
          action: g.action.value
        }
      end)
    end)
  end

  @doc """
  List active guards.
  """
  def list_active_guards do
    history = Storage.list()
    find_active_guards(history)
    |> Enum.map(fn g ->
      %{
        model: g.model.value,
        concept: g.model.base,
        field: g.attribute.value,
        condition: g.condition.value,
        action_type: g.action_type,
        action: g.action.value
      }
    end)
  end
end
